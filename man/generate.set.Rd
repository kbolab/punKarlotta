% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{generate.set}
\alias{generate.set}
\title{Funzione per generare uno studio}
\usage{
generate.set(numeroCovariate = 1, numeroCampioni.x.covariata = 10,
  noise.intra.X = list(), noise.inter.X = list(),
  intra.power.distorsion = c(), inter.power.distorsion = 1)
}
\arguments{
\item{numeroCovariate}{(numeric) il numero di covariate}

\item{numeroCampioni.x.covariata}{(numeric) quanti campioni per covariata}

\item{noise.intra.X}{(list) il tipo di rumore che può affliggere la covariata. E' una lista di liste, che possono a loro volta essere composte come segue:
\itemize{
      \item \code{ list("gaussian"=list("mean"= < mean value>, "sd"= <SD value>)) } please refer to nrnorm() function to see the meaning of 'mean' and 'sd' values
      \item \code{ list("uniform"=list("min"= < min value>, "max"= <max value>)) } please refer to runif() function to see the meaning of 'min' and 'max' values
      \item \code{ list("beta"=list("shape"= < shape value>, "scale"= <scale value>)) } please refer to rbeta() function to see the meaning of 'shape' and 'scale' values
      \item \code{ list("weibull"=list("shape"= < shape value>, "scale"= <scale value>)) } please refer to rweibull() function to see the meaning of 'shape' and 'scale' values
      }}

\item{noise.inter.X}{(list) il tipo di rumore che può affliggere la sommatoria finale. E' una lista la cui sintassi è esattamente identica a 'noise.intra.X'}

\item{intra.power.distorsion}{(array, default = c()) un array che indica l'esponenziale di ogni covariata. Il default (c() ) equivale a metterle tutte a 1.}

\item{inter.power.distorsion}{(array, default = 1) un array che indica l'esponenziale della somma dei contributi delle covariate.}
}
\description{
E' una funzione che genera le covariate e l'outcome, in accordo con le regole (di distorsione) passate.  L'outcome è memorizzato nella variabile Y, e si costruisce a partire da un numero di  covariate X + un eventuale bias di rumore addittivo.
}
\details{
La formula complessiva per il calcolo di Y è la seguente: \deqn{ y = \{noise.inter.X + \sum_{i = 1}^{numeroCovariate} [covariata(i)+noise.intra.X(i) ]^ {intra.power.distorsion}  \}^{inter.power.distorsion} }
dove iX.min = intra.min.power.distorsion, iX.max = intra.max.power.distorsion, eX.min = inter.min.power.distorsion e eX.max = inter.max.power.distorsion. Notare che se le distorsioni esponenziali vengono lasciate a default, la formula è perfettamente lineare.
}
\examples{
\dontrun{

# il caso più semplice: lineare diretto di una covariata 
a<-generate.set()
plot(x = a$x$`1`, y = a$y)

# aggiungiamo un po' di rumore gaussiano alla covariata
a<-generate.set(noise.intra.X = list("gaussian"=list("mean"=0,"sd"=0.2)))
plot(x = a$x$`1`, y = a$y)

# .. o un po' di rumore a caso fra due distribuzioni gaussiane differenti ed una weibull
a<-generate.set(noise.intra.X = list("gaussian"=list("mean"=0,"sd"=0.2), "gaussian"=list("mean"=0.1,"sd"=0.3),"weibull"=list("shape"=1,"scale"=0) ))    
plot(x = a$x$`1`, y = a$y)

# ora una semplice monovariata con un pizzico di rumore gaussiano e esponenziale di 3.1 (per dare un po' di non linearità)
a<-generate.set( intra.power.distorsion=3.1 , noise.intra.X = list("gaussian"=list("mean"=0,"sd"=0.05)))
plot(x = a$x$`1`, y = a$y)

# Ovviamente possiamo fare una Y basata sulla somma di più covariate... 
# notate come la linearità fra x1 1 y è "abbattuta" dal peso dei coefficienti di x2
# (andateci piano ad elevare a potenza!)
a<-generate.set(numeroCovariate = 2, intra.power.distorsion=c(1,3) )
plot(x = a$x$`1`, y = a$y)
plot(x = a$x$`2`, y = a$y)
summary(glm(y ~ x1 + x2, data=data.frame("y"=a$y,"x1"=a$x$`1`,"x2"=a$x$`2`)))
 
 
} 
}

